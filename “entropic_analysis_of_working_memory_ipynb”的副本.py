# -*- coding: utf-8 -*-
"""“Entropic_Analysis_of_Working_Memory.ipynb”的副本

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l98XRQ7AMN3ybSXwRTrNLhHGOXawoQmf
"""

import random
import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import norm
import math
np.random.seed(6)
result = np.zeros(500)
A = np.mat([[-10, 1, 4, 5], [3, -9, 4, 2], [2, 1, -10, 7], [5, 2, 8, -15]])
S = 1/(-A.diagonal())
state = []
time = []
statstic = [];
for i in range(0,A.shape[1]):
  statstic.append([])

num=1
time.append(0)
state.append(num)
tao=0
r1 = np.random.random()
tao1 = ((S[0,num-1]))*np.log(1.0/r1)
tao = tao + tao1
time.append(tao)
state.append(num)


for i in range(20):

  r2 = np.random.random()
  sum = 0.0
  for j in range(0, A.shape[1]):
    if(num != j):
        sum = sum + (-1.0 * (A[num,j] / A[num,num]))
        if(r2 <= sum and j != num):
          state.append(j+1)
          state.append(j+1)
          statstic[j].append(tao1)
          num = j
          break

  r3 = np.random.random()
  time.append(tao)
  tao1 = ((S[0,num-1]))*np.log(1.0/r3)
  tao = tao+tao1
  time.append(tao)

plt.plot(time, state)
#plt.hist(statstic[0])
#plt.hist(statstic[1])
#plt.hist(statstic[2])

plt.hist(statstic[0])
#plt.hist(statstic[1])
#plt.hist(statstic[2])

#print(statstic[0])
s = np.sum (statstic[3])
print (s)
total = np.sum (statstic[0]) + np.sum (statstic[1]) + np.sum (statstic[2]) + np.sum (statstic[3])
print (total)
result = s/total
print(result)

import random
import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import norm
import math
np.random.seed(6)
result = np.zeros(500)
f= 5
r= 5
b= 1
R= 5
A = np.mat([[-f-r, b, 0, 0, R, 0, 0, 0], [r, -f-r, b, 0, 0, R, 0, 0], [0, r, -f-r, b, 0, 0, R, 0], [0, r, -f-r, b, 0, 0, 0, R]])
S = 1/(-A.diagonal())
state = []
time = []
statstic = [];
for i in range(0,A.shape[1]):
  statstic.append([])

num=1
time.append(0)
state.append(2*num)
tao=0
r1 = np.random.random()
tao1 = ((S[0,num-1]))*np.log(1.0/r1)
tao = tao + tao1
time.append(tao)
state.append(num)


for i in range(2000):

  r2 = np.random.random()
  sum = 0.0
  for j in range(0, A.shape[1]):
    if(num != j):
        sum = sum + (-1.0 * (A[num,j] / A[num,num]))
        if(r2 <= sum and j != num):
          state.append(j+1)
          state.append(j+1)
          statstic[j].append(tao1)
          num = j
          break

  r3 = np.random.random()
  time.append(tao)
  tao1 = ((S[0,num-1]))*np.log(1.0/r3)
  tao = tao+tao1
  time.append(tao)

plt.plot(time, state)
#plt.hist(statstic[0])
#plt.hist(statstic[1])
#plt.hist(statstic[2])

#没有fire
import random
import numpy as np
from matplotlib import pyplot as plt
from scipy.stats import norm
import math
np.random.seed(6)
result = np.zeros(500)
r = 50
b = 3
A = np.mat([[-r, r, 0, 0], [b, -b-r, r, 0], [0, b, -b-r, r], [0, 0, b, -b]])
S = 1/(-A.diagonal())
state = []
time = []
statstic = [];
for i in range(0,A.shape[1]):
  statstic.append([])

num=1
time.append(0)
state.append(num)
tao=0
r1 = np.random.random()
tao1 = ((S[0,num-1]))*np.log(1.0/r1)
tao = tao + tao1
time.append(tao)
state.append(num)


for i in range(20):

  r2 = np.random.random()
  sum = 0.0
  for j in range(0, A.shape[1]):
    if(num != j):
        sum = sum + (-1.0 * (A[num,j] / A[num,num]))
        if(r2 <= sum and j != num):
          state.append(j+1)
          state.append(j+1)
          statstic[j].append(tao1)
          num = j
          break

  r3 = np.random.random()
  time.append(tao)
  tao1 = ((S[0,num-1]))*np.log(1.0/r3)
  tao = tao+tao1
  time.append(tao)

plt.plot(time, state)
#plt.hist(statstic[0])
#plt.hist(statstic[1])
#plt.hist(statstic[2])